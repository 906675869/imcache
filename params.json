{
  "name": "Imcache",
  "tagline": "Imcache is a Java Caching Library.",
  "body": "imcache\r\n=======\r\nImcache is a Java Caching Library.Imcache intends to speed up applications by providing a means to manage cached data. It offers solutions ranging from small applications to large scale applications. It supports n-level caching hierarchy where it supports various kind of caching methods like heap, offheap, and more. Imcache will also support well-known caching solutions like memcache and redis. To extend, you can define a heapcache backed by offheap cache which is also backed by database. If a key is not found in heap, it will be asked to offheap and so on. In order to use imcache, you need to specify your dependency as follows.\r\n###Pom Reference\r\n```xml\r\n<dependency>\r\n  <groupId>com.cetsoft</groupId>\r\n  <artifactId>imcache</artifactId>\r\n  <version>0.1.1</version><!--Can be updated for later versions-->\r\n</dependency>\r\n```\r\n###Simple Application\r\n```java\r\nCache<String,User> cache = CacheBuilder.heapCache().\r\ncacheLoader(new CacheLoader<String, User>() {\r\n    public User load(String key) {\r\n        return userDAO.get(key);\r\n    }\r\n}).evictionListener(new EvictionListener<String, User>{\r\n    public onEviction(String key, User user){\r\n        userDAO.save(key, user);\r\n    }\r\n}).capacity(10000).build();\r\n//If there is not a user in the heap cache it'll be loaded via userDAO.\r\nUser user = cache.get(\"#unique identifier\"); \r\nUser newUser = new User(\"email\", \"Richard\", \"Murray\")\r\n//When maximum value for cache size is reached, eviction event occurs.\r\n//In case of eviction, newUser will be saved to db.\r\ncache.put(newUser.getEmail(), newUser);\r\n```\r\n###The Cache Interface\r\nImcache supports simple operation defined by the cache interface. Cache interface provides general methods that is implemented by all imcache caches. See the methods below.\r\n```java\r\npublic interface Cache<K, V> {\r\n    void put(K key, V value);\r\n    V get(K key);\r\n    V invalidate(K key);\r\n    void clear()\r\n    double hitRatio();\r\n}\r\n```\r\n###The Cache Builder\r\nCache Builder is one of the core asset of the imcache. You can create simple heapCaches to complexOffHeapCaches via \r\nCache Builder. Let's see Cache Builder in action below.\r\n```java\r\nvoid example(){\r\n    Cache<Integer,Integer> cache = CacheBuilder.heapCache().\r\n    cacheLoader(new CacheLoader<Integer, Integer>() {\r\n  \t//Here you can load the key from another cache like offheapcache\r\n        public Integer load(Integer key) {\r\n            return null;\r\n        }\r\n    }).capacity(10000).build(); \r\n}\r\n```\r\n###The Cache Loader\r\nThe CacheLoader interface for loading values with specified keys. The class that is interested in loading values \r\nfrom a resource implements this interface. When data is not found the cache, load method of CacheLoader is called.\r\n###The Eviction Listener\r\nThe listener interface for receiving eviction events. The class that is interested in processing a eviction event\r\nimplements this interface. When the eviction event occurs,that object's onEviction method is invoked.\r\n###The Heap Cache\r\nHeapCache uses LRU(Least Recently Used) as eviction strategy by the help of LinkedHashMap. As a result, \r\nHeapCache discards the least recently used items first when eviction required. Eviction occurs if the size of\r\nthe cache is equal to the cache capacity in a put operation.\r\n###The Concurrent Heap Cache\r\nConcurrentHeapCache uses LRU(Least Recently Used) as eviction strategy by the help of ConcurrentLinkedHashMap. \r\nAs a result, ConcurrentHeapCache discards the least recently used items firstwhen eviction required.\r\nEviction occurs if the size of the cache is equal to the cache capacity in a put operation\r\n###The Off Heap Cache\r\nThe Class OffHeapCache is a cache that uses offheap byte buffers to store or retrieve data by serializing\r\nitems into bytes. To do so, OffHeapCache uses pointers to point array location of an item. OffHeapCache clears\r\nthe buffers periodically to gain free space if buffers are dirty(unused memory). It also does eviction depending on\r\naccess time to the objects.\r\nTo make offheap cache work to JVM Parameters <b>\"-XX:MaxDirectMemorySize=4g\"</b> must be set. Buffer capacity of 8 mb \r\nis a good choice to start OffHeapCache. Let's see sample OffHeapCache use.\r\n```java\r\nvoid example(){\r\n    //8388608 is 8 MB and 10 buffers. 8MB*10 = 80 MB.\r\n    OffHeapByteBufferStore bufferStore = new OffHeapByteBufferStore(8388608, 10);\r\n    final Cache<Integer,SimpleObject> offHeapCache = CacheBuilder.offHeapCache().\r\n    storage(bufferStore).build();\r\n}\r\n```\r\nBy default configuration, OffHeapCache will try to clean the places which are not used and marked as \r\ndirty periodically. What is more, it will do eviction periodically, too.\r\n\r\n###The Versioned Off Heap Cache\r\nThe Class VersionedOffHeapCache is a type of offheap cache where cache items have versions that are incremented for each update.\r\nTo make versioned off heap cache work to JVM Parameters <b>\"-XX:MaxDirectMemorySize=4g\"</b> must be set. Buffer capacity of 8 mb \r\nis a good choice to start VersionedOffHeapCache. Let's see sample VersionedOffHeapCache use.\r\n```java\r\nvoid example(){\r\n    //8388608 is 8 MB and 10 buffers. 8MB*10 = 80 MB.\r\n    OffHeapByteBufferStore bufferStore = new OffHeapByteBufferStore(8388608, 10);\r\n    final Cache<Integer,VersionedItem<SimpleObject>> offHeapCache = \r\n    CacheBuilder.versionedOffHeapCache().storage(bufferStore).build();\r\n    VersionedItem<SimpleObject> versionedItem = offHeapCache.get(12);\r\n}\r\n```\r\n\r\n###Searching, Indexing and Query Execution\r\nimcache provides searching for all the caches by default. Searching is done by execute method of SearchableCache.\r\nExecute method takes a Query as an input and returns results as list. A query consists of criteria and filter. Here\r\nis an example use for queries.\r\n```java\r\nvoid example(){\r\n    SearchableCache<Integer, SimpleObject> cache = CacheBuilder.heapCache().\r\n    addIndex(\"j\", IndexType.RANGE_INDEX).build();\r\n    cache.put(0, createObject());\r\n    cache.put(1, createObject());\r\n    cache.put(2, createObject());\r\n    List<SimpleObject> objects = cache.execute(CacheQuery.newQuery().\r\n    setCriteria(new BetweenCriteria(\"j\",1,3).or(new ETCriteria(\"j\", 3))).\r\n    setFilter(new LEFilter(\"k\", 3)));\r\n    for (SimpleObject simpleObject : objects) {\r\n        System.out.println(simpleObject);\r\n    }\r\n}\r\n```\r\n\r\n<i>To learn more about imcache please look at examples provided.</i>\r\n",
  "google": "",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}